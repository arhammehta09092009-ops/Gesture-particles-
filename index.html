<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Heart for TWISHA - Stable</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; touch-action: none; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>

let scene, camera, renderer;
let particles = [], targets = [];
let particleCount = 800;
let colorHue = 0;
let tilt = {x:0, y:0};
let touches = [];

// Heart shape function
function heartFunction(t){
    let x = 16*Math.pow(Math.sin(t),3);
    let y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    return [x,y];
}

// Create particles with target positions
function createParticles(){
    const geometry = new THREE.SphereGeometry(0.5, 8, 8);
    const material = new THREE.MeshBasicMaterial({color:0xff69b4});

    // Heart particles
    for(let i=0;i<particleCount/2;i++){
        let t = Math.random()*Math.PI*2;
        let [x,y] = heartFunction(t);
        let p = new THREE.Mesh(geometry, material.clone());
        p.position.set((Math.random()-0.5)*5, (Math.random()-0.5)*5, (Math.random()-0.5)*5);
        p.velocity = new THREE.Vector3();
        scene.add(p);
        particles.push(p);
        targets.push(new THREE.Vector3(x*2, y*2, 0));
    }

    // Name particles using canvas
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.font = '48px Arial';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText('TWISHA', canvas.width/2, canvas.height/1.5);
    const imageData = ctx.getImageData(0,0,canvas.width,canvas.height).data;

    for(let y=0; y<canvas.height; y+=2){
        for(let x=0; x<canvas.width; x+=2){
            let alpha = imageData[(y*canvas.width+x)*4 +3];
            if(alpha>128){
                let px = (x - canvas.width/2)/4;
                let py = -(y - canvas.height/2)/4;
                let p = new THREE.Mesh(geometry, material.clone());
                p.position.set((Math.random()-0.5)*5, (Math.random()-0.5)*5, (Math.random()-0.5)*5);
                p.velocity = new THREE.Vector3();
                scene.add(p);
                particles.push(p);
                targets.push(new THREE.Vector3(px, py, 0));
            }
        }
    }
}

// Initialize scene
function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    createParticles();
    animate();
}

// Tilt handling
window.addEventListener('deviceorientation', e=>{
    tilt.y = THREE.MathUtils.degToRad(e.gamma||0)/2;
    tilt.x = THREE.MathUtils.degToRad(e.beta||0)/2;
});

// Shake detection
let lastAccel={x:null,y:null,z:null}, shakeThreshold=15;
window.addEventListener('devicemotion', e=>{
    let a=e.accelerationIncludingGravity;
    if(lastAccel.x!==null){
        let delta = Math.abs(a.x-lastAccel.x)+Math.abs(a.y-lastAccel.y)+Math.abs(a.z-lastAccel.z);
        if(delta>shakeThreshold) explodeParticles();
    }
    lastAccel={x:a.x,y:a.y,z:a.z};
});

// Tap for color shift
window.addEventListener('touchstart', e=>{ colorHue=(colorHue+60)%360; });

// Multi-touch
function copyTouch(t){return {id:t.identifier,x:t.pageX,y:t.pageY};}
document.addEventListener("touchstart", e=>{for(let t of e.changedTouches) touches.push(copyTouch(t));});
document.addEventListener("touchmove", e=>{for(let t of e.changedTouches){let idx=touches.findIndex(a=>a.id===t.identifier); if(idx>=0) touches[idx]={id:t.identifier,x:t.pageX,y:t.pageY};}});
document.addEventListener("touchend", e=>{for(let t of e.changedTouches){let idx=touches.findIndex(a=>a.id===t.identifier); if(idx>=0) touches.splice(idx,1);}});

// Particle explosion
function explodeParticles(){
    particles.forEach(p=>{
        let angle=Math.random()*Math.PI*2;
        let speed=5+Math.random()*5;
        p.velocity.x=Math.cos(angle)*speed;
        p.velocity.y=Math.sin(angle)*speed;
        p.velocity.z=(Math.random()-0.5)*speed;
    });
}

// Animate
function animate(){
    requestAnimationFrame(animate);
    colorHue+=0.2;

    particles.forEach((p,i)=>{
        let target = targets[i];

        // Move toward target with easing
        let dir = new THREE.Vector3().subVectors(target, p.position).multiplyScalar(0.05);
        p.velocity.add(dir);

        // Tilt attraction
        p.velocity.x += tilt.y*0.02;
        p.velocity.y += tilt.x*0.02;

        // Multi-touch telekinesis
        touches.forEach(t=>{
            let nx = (t.x/window.innerWidth -0.5)*50;
            let ny = -(t.y/window.innerHeight -0.5)*50;
            let force = new THREE.Vector3(nx - p.position.x, ny - p.position.y, -p.position.z);
            force.multiplyScalar(0.02);
            p.velocity.add(force);
        });

        // Apply velocity with damping
        p.position.add(p.velocity);
        p.velocity.multiplyScalar(0.92);

        // Scale shimmer
        let scale=1+0.3*Math.sin(Date.now()*0.005+p.position.x);
        p.scale.set(scale,scale,scale);

        // Rainbow color
        let h=(colorHue+p.position.x)%360;
        p.material.color.setHSL(h/360,1,0.5);
    });

    renderer.render(scene,camera);
}

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();

</script>
</body>
</html>
