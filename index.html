<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jedi Particle Force</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; touch-action: none; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>

let scene, camera, renderer;
let particles = [], particleCount = 500;
let colorHue = 0;
let tilt = {x:0, y:0};
let touches = [];

// Initialize Three.js
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 60;

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.SphereGeometry(0.6, 8, 8);

    for(let i=0;i<particleCount;i++){
        let material = new THREE.MeshBasicMaterial({color: new THREE.Color(`hsl(${Math.random()*360},100%,50%)`)});
        let p = new THREE.Mesh(geometry, material);
        p.position.set((Math.random()-0.5)*100,(Math.random()-0.5)*100,(Math.random()-0.5)*100);
        p.velocity = new THREE.Vector3();
        particles.push(p);
        scene.add(p);
    }

    animate();
}

// Device tilt
window.addEventListener('deviceorientation', e => {
    tilt.y = THREE.MathUtils.degToRad(e.gamma || 0)/2;
    tilt.x = THREE.MathUtils.degToRad(e.beta || 0)/2;
});

// Shake detection
let lastAccel = {x:null,y:null,z:null}, shakeThreshold=15;
window.addEventListener('devicemotion', e=>{
    let a=e.accelerationIncludingGravity;
    if(lastAccel.x!==null){
        let delta = Math.abs(a.x-lastAccel.x)+Math.abs(a.y-lastAccel.y)+Math.abs(a.z-lastAccel.z);
        if(delta>shakeThreshold) explodeParticles();
    }
    lastAccel={x:a.x,y:a.y,z:a.z};
});

// Tap for color shift
window.addEventListener('touchstart', e=>{
    colorHue=(colorHue+60)%360;
});

// Multi-touch handling
function copyTouch(t){return {id:t.identifier,x:t.pageX,y:t.pageY};}

document.addEventListener("touchstart", e=>{for(let t of e.changedTouches) touches.push(copyTouch(t));});
document.addEventListener("touchmove", e=>{for(let t of e.changedTouches){let idx=touches.findIndex(a=>a.id===t.identifier); if(idx>=0) touches[idx]={id:t.identifier,x:t.pageX,y:t.pageY};}});
document.addEventListener("touchend", e=>{for(let t of e.changedTouches){let idx=touches.findIndex(a=>a.id===t.identifier); if(idx>=0) touches.splice(idx,1);}});

// Particle explosion
function explodeParticles(){
    particles.forEach(p=>{
        let angle = Math.random()*Math.PI*2;
        let speed = 5+Math.random()*5;
        p.velocity.x=Math.cos(angle)*speed;
        p.velocity.y=Math.sin(angle)*speed;
        p.velocity.z=(Math.random()-0.5)*speed;
    });
}

// Animate
function animate(){
    requestAnimationFrame(animate);
    colorHue+=0.2;

    particles.forEach(p=>{
        // Tilt attraction with easing
        p.position.x += tilt.y*0.3 + (Math.random()-0.5)*0.02;
        p.position.y += tilt.x*0.3 + (Math.random()-0.5)*0.02;

        // Multi-touch telekinesis
        touches.forEach(t=>{
            let nx = (t.x/window.innerWidth - 0.5)*100;
            let ny = -(t.y/window.innerHeight - 0.5)*100;
            let dir = new THREE.Vector3(nx-p.position.x,ny-p.position.y,-p.position.z);
            dir.multiplyScalar(0.02); // smooth pull
            p.velocity.add(dir);
        });

        // Apply velocity with damping
        p.position.add(p.velocity);
        p.velocity.multiplyScalar(0.92);

        // Rotation & shimmer
        p.rotation.x+=0.01;
        p.rotation.y+=0.01;
        let scale=1+0.3*Math.sin(Date.now()*0.005+p.position.x);
        p.scale.set(scale,scale,scale);

        // Smooth rainbow cycling
        let h=(colorHue+p.position.x)%360;
        p.material.color.setHSL(h/360,1,0.5);
    });

    renderer.render(scene,camera);
}

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();

</script>
</body>
</html>
